<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Minecraft Head Hunter</title>
  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- JSZip (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <style>
    /* Minimal scrollbars for dense grids */
    * { scrollbar-width: thin; scrollbar-color: #64748b #0f172a; }
    ::-webkit-scrollbar { height: 8px; width: 8px; }
    ::-webkit-scrollbar-thumb { background: #64748b; border-radius: 8px; }
    ::-webkit-scrollbar-track { background: #0f172a; }
  </style>
</head>
<body class="bg-slate-950 text-slate-100">
  <div id="app" class="mx-auto max-w-[1400px] min-h-screen grid grid-cols-1 lg:grid-cols-[1fr_360px] gap-4 p-4">

    <!-- MAIN COLUMN -->
    <div class="flex flex-col gap-4 min-w-0">
      <!-- Header / Controls -->
      <header class="rounded-2xl bg-slate-900/60 border border-slate-800 p-4 sticky top-4 z-10 backdrop-blur supports-[backdrop-filter]:bg-slate-900/40">
        <div class="flex flex-col md:flex-row md:items-end gap-3">
          <div class="flex-1">
            <h1 class="text-2xl font-bold tracking-tight">Minecraft Head Hunter</h1>
            <p id="status" class="text-sm text-slate-400 mt-1">Loading catalog…</p>
          </div>
          <div class="flex flex-col sm:flex-row gap-2 w-full md:w-auto">
            <label class="relative flex-1">
              <input id="searchInput" type="search" placeholder="Search names or tags…" class="w-full h-11 rounded-xl bg-slate-800/70 border border-slate-700 px-4 pr-10 outline-none focus:ring-2 focus:ring-cyan-400/50" />
              <span class="pointer-events-none absolute right-3 top-1/2 -translate-y-1/2 text-slate-400">⌘K</span>
            </label>
            <select id="categorySelect" class="h-11 rounded-xl bg-slate-800/70 border border-slate-700 px-4 outline-none focus:ring-2 focus:ring-cyan-400/50">
              <option value="__ALL__">All categories</option>
            </select>
          </div>
        </div>
      </header>

      <!-- Grid -->
      <section class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
        <div id="grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 xl:grid-cols-8 2xl:grid-cols-10 gap-2"></div>
        <div id="sentinel" class="py-6 text-center text-slate-400">Loading more…</div>
      </section>
    </div>

    <!-- CART SIDEBAR -->
    <aside class="rounded-2xl bg-slate-900/60 border border-slate-800 p-4 h-fit sticky top-4">
      <div class="flex items-center justify-between gap-2">
        <h2 class="text-lg font-semibold">Cart</h2>
        <span id="cartCount" class="inline-flex items-center justify-center rounded-full bg-cyan-500/20 text-cyan-300 text-sm px-2 py-1">0</span>
      </div>
      <p class="text-xs text-slate-400 mt-1">Click any head to add it to your cart. Remove from the list below.</p>

      <ul id="cartList" class="divide-y divide-slate-800 mt-3 max-h-[55vh] overflow-auto"></ul>

      <button id="checkoutBtn" class="w-full mt-4 h-11 rounded-xl bg-cyan-500 text-slate-900 font-semibold disabled:opacity-40 disabled:cursor-not-allowed hover:bg-cyan-400 transition">
        Checkout & Download ZIP
      </button>
      <p id="checkoutNote" class="text-xs text-slate-400 mt-2">
        Filenames use <code>name_tags_category.png</code>. You’ll get exactly what’s in the cart, nothing sneaky.
      </p>
    </aside>
  </div>

  <template id="cardTpl">
    <button class="group relative rounded-xl bg-slate-800/60 hover:bg-slate-800 border border-slate-700 p-2 text-left">
      <img class="h-16 w-16 mx-auto block rounded-md shadow" loading="lazy" />
      <div class="mt-2">
        <p class="text-sm font-medium line-clamp-1 name"></p>
        <p class="text-[10px] text-slate-400 line-clamp-1 tags"></p>
      </div>
      <span class="absolute right-2 top-2 text-[10px] px-1.5 py-0.5 rounded bg-slate-700/70 text-slate-200 category"></span>
      <span class="absolute inset-0 hidden group-hover:flex items-center justify-center bg-black/40 text-xs font-semibold rounded-xl">Add to cart</span>
    </button>
  </template>

  <template id="cartItemTpl">
    <li class="flex items-center gap-3 py-2">
      <img class="h-10 w-10 rounded" />
      <div class="min-w-0 flex-1">
        <p class="text-sm font-medium truncate name"></p>
        <p class="text-[10px] text-slate-400 truncate meta"></p>
      </div>
      <button class="remove text-xs px-2 py-1 rounded bg-slate-800 border border-slate-700 hover:bg-slate-700">Remove</button>
    </li>
  </template>

  <script>
    // ---------------------- Utility ----------------------
    const $ = (sel, root = document) => root.querySelector(sel);
    const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));

    const slugify = (s) => (s || "")
      .toLowerCase()
      .normalize("NFKD").replace(/[^\w\s-]/g, "")
      .trim().replace(/\s+/g, "-").replace(/-+/g, "-");

    const unique = (arr) => Array.from(new Set(arr.filter(Boolean)));

    // Try to fetch binary with CORS; if blocked, fall back to a proxy
    async function fetchImageBlobWithFallback(url) {
      // First try direct
      try {
        const res = await fetch(url, { mode: "cors" });
        if (res.ok && res.type !== "opaque") return await res.blob();
      } catch {}
      // Fallback proxy: images.weserv.nl expects schema-less host in `url=`
      const proxy = `https://images.weserv.nl/?url=${encodeURIComponent(url.replace(/^https?:\/\//, ""))}`;
      const proxied = await fetch(proxy);
      if (!proxied.ok) throw new Error("Image fetch failed");
      return await proxied.blob();
    }

    // Decode base64 head value -> textures URL, if needed
    function extractTextureUrlFromValue(valueB64) {
      try {
        const json = JSON.parse(atob(valueB64));
        return json?.textures?.SKIN?.url || null;
      } catch { return null; }
    }

    // Standardize incoming record to our shape
    function standardizeRecord(raw, idx = 0) {
      // Attempt to locate fields across common community schemas
      const name = raw.name || raw.Value?.name || raw.displayName || raw.title || `head-${idx}`;
      const category = raw.category || raw.categories?.[0] || raw.type || "misc";
      const tags = unique([...(raw.tags || []), ...(raw.keywords || []), ...(typeof raw.search === 'string' ? raw.search.split(',') : (raw.search || []))])
        .map(t => String(t).trim()).filter(Boolean);
      const textureUrl = raw.textureUrl || raw.texture || raw.image?.url || raw.url || extractTextureUrlFromValue(raw.value || raw.base64 || raw.b64 || raw.properties?.value) || null;
      const texture = textureUrl && textureUrl.startsWith('http') ? textureUrl : (textureUrl ? `https://textures.minecraft.net/texture/${textureUrl}` : null);
      const id = raw.uuid || raw.id || `${name}:${texture || idx}`;
      return { id, name, category, tags, textureUrl: texture };
    }

    // ---------------------- State ----------------------
    const state = {
      all: [],
      filtered: [],
      categories: [],
      visibleCount: 0,
      pageSize: 160,
      cart: new Map(), // key: id, value: head
      loaded: false,
    };

    // ---------------------- DOM Refs ----------------------
    const statusEl = $('#status');
    const gridEl = $('#grid');
    const sentinelEl = $('#sentinel');
    const searchInput = $('#searchInput');
    const categorySelect = $('#categorySelect');
    const cartList = $('#cartList');
    const cartCount = $('#cartCount');
    const checkoutBtn = $('#checkoutBtn');

    // ---------------------- Data Loading ----------------------
    const DATASET_URLS = [
      // Widely mirrored community dataset (contains many custom heads)
      'https://raw.githubusercontent.com/InventivetalentDev/minecraft-heads/master/heads.json',
      // Alternative mirror(s) could be added here
    ];

    const SAMPLE_DATA = [
      // Minimal sample so UI is testable offline
      { name: 'Earth Globe', category: 'decoration', tags: ['planet','earth','globe'], textureUrl: 'https://textures.minecraft.net/texture/4b4d8a2d9a7e9d0c3c4c3c8b4cf3f4b8df2cf7c1d2b9b7a8c8a46d8e2a6e8a4' },
      { name: 'Orange', category: 'food', tags: ['fruit','citrus'], textureUrl: 'https://textures.minecraft.net/texture/2e2b7f8c6ad3c7a4b1c8d6e0f1a2b3c4d5e6f70890abcdeffedcba0987654321' },
    ];

    async function loadCatalog() {
      statusEl.textContent = 'Loading catalog…';
      for (const url of DATASET_URLS) {
        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error('HTTP ' + res.status);
          const json = await res.json();
          const arr = Array.isArray(json) ? json : (json?.heads || json?.items || []);
          if (!Array.isArray(arr) || arr.length === 0) throw new Error('Empty dataset');
          const standardized = arr.map(standardizeRecord).filter(h => h.textureUrl);
          if (standardized.length === 0) throw new Error('No usable entries');
          bootstrap(standardized);
          statusEl.textContent = `Loaded ${standardized.length.toLocaleString()} heads.`;
          return;
        } catch (e) {
          // Try next source
        }
      }
      // Fallback to sample data
      const fallback = SAMPLE_DATA.map(standardizeRecord);
      bootstrap(fallback);
      statusEl.innerHTML = 'Loaded sample data only. <span class="text-amber-300">External dataset blocked or unavailable.</span>';
    }

    function bootstrap(list) {
      state.all = list;
      const cats = unique(list.map(h => h.category)).sort((a,b) => a.localeCompare(b));
      state.categories = cats;
      // Populate categories
      for (const c of cats) {
        const opt = document.createElement('option');
        opt.value = c; opt.textContent = c;
        categorySelect.appendChild(opt);
      }
      // Initial filter
      applyFilters();
      // Setup infinite scroll
      setupInfiniteScroll();
    }

    // ---------------------- Filtering & Rendering ----------------------
    function applyFilters() {
      const q = searchInput.value.trim().toLowerCase();
      const cat = categorySelect.value;
      const tokens = q ? q.split(/\s+/).filter(Boolean) : [];

      let arr = state.all;
      if (cat && cat !== '__ALL__') arr = arr.filter(h => (h.category || '').toLowerCase() === cat.toLowerCase());
      if (tokens.length) {
        arr = arr.filter(h => {
          const hay = [h.name, h.category, ...(h.tags||[])].join(' ').toLowerCase();
          return tokens.every(t => hay.includes(t));
        });
      }
      state.filtered = arr;
      state.visibleCount = Math.min(arr.length, state.pageSize);
      renderGrid();
      sentinelEl.style.display = state.visibleCount < state.filtered.length ? '' : 'none';
    }

    function renderGrid() {
      gridEl.innerHTML = '';
      const tpl = $('#cardTpl');
      for (let i = 0; i < state.visibleCount; i++) {
        const h = state.filtered[i];
        const frag = tpl.content.cloneNode(true);
        const card = frag.querySelector('button');
        const img = frag.querySelector('img');
        const nameEl = frag.querySelector('.name');
        const tagsEl = frag.querySelector('.tags');
        const catEl = frag.querySelector('.category');

        img.src = h.textureUrl; // display ok without CORS
        img.alt = h.name;
        nameEl.textContent = h.name;
        tagsEl.textContent = (h.tags && h.tags.length) ? h.tags.join(', ') : '—';
        catEl.textContent = h.category || 'misc';

        card.onclick = () => addToCart(h);
        gridEl.appendChild(frag);
      }
    }

    function setupInfiniteScroll() {
      const io = new IntersectionObserver((entries) => {
        for (const e of entries) {
          if (e.isIntersecting) {
            const more = Math.min(state.filtered.length, state.visibleCount + state.pageSize);
            if (more > state.visibleCount) {
              state.visibleCount = more;
              renderGrid();
            }
            sentinelEl.style.display = state.visibleCount < state.filtered.length ? '' : 'none';
          }
        }
      });
      io.observe(sentinelEl);
    }

    // ---------------------- Cart ----------------------
    function addToCart(head) {
      if (!state.cart.has(head.id)) state.cart.set(head.id, head);
      renderCart();
    }

    function removeFromCart(id) {
      state.cart.delete(id);
      renderCart();
    }

    function renderCart() {
      cartList.innerHTML = '';
      const tpl = $('#cartItemTpl');
      for (const [id, h] of state.cart) {
        const frag = tpl.content.cloneNode(true);
        const img = frag.querySelector('img');
        const nameEl = frag.querySelector('.name');
        const metaEl = frag.querySelector('.meta');
        const btn = frag.querySelector('.remove');
        img.src = h.textureUrl;
        img.alt = h.name;
        nameEl.textContent = h.name;
        metaEl.textContent = `${h.category}${(h.tags?.length ? ' · ' + h.tags.join(', ') : '')}`;
        btn.onclick = () => removeFromCart(id);
        cartList.appendChild(frag);
      }
      const count = state.cart.size;
      cartCount.textContent = String(count);
      checkoutBtn.disabled = count === 0;
    }

    // ---------------------- Checkout / ZIP ----------------------
    function makeFileName(head) {
      const name = slugify(head.name);
      const tags = (head.tags && head.tags.length) ? slugify(head.tags.join('-')) : 'no-tags';
      const cat = slugify(head.category || 'misc');
      // Ensure something sane
      const safe = [name || 'head', tags, cat].join('_').replace(/[^a-z0-9_\-]/g, '');
      return safe + '.png';
    }

    async function checkout() {
      checkoutBtn.disabled = true;
      const original = checkoutBtn.textContent;
      const zip = new JSZip();

      const items = Array.from(state.cart.values());
      let ok = 0, fail = 0;

      for (let i = 0; i < items.length; i++) {
        const h = items[i];
        checkoutBtn.textContent = `Fetching ${i+1}/${items.length}…`;
        try {
          const blob = await fetchImageBlobWithFallback(h.textureUrl);
          const arrayBuf = await blob.arrayBuffer();
          zip.file(makeFileName(h), arrayBuf);
          ok++;
        } catch (e) {
          fail++;
        }
      }

      checkoutBtn.textContent = 'Zipping…';
      const out = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(out);

      const a = document.createElement('a');
      a.href = url;
      a.download = `minecraft-heads_${new Date().toISOString().slice(0,10)}.zip`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);

      checkoutBtn.textContent = original;
      checkoutBtn.disabled = state.cart.size === 0;

      if (fail) {
        statusEl.innerHTML = `<span class="text-amber-300">Downloaded ${ok} file(s); ${fail} failed due to CORS or network.</span>`;
      } else {
        statusEl.textContent = `Downloaded ${ok} file(s).`;
      }
    }

    // ---------------------- Events ----------------------
    searchInput.addEventListener('input', () => applyFilters());
    categorySelect.addEventListener('change', () => applyFilters());
    checkoutBtn.addEventListener('click', checkout);
    // Keyboard shortcut: Cmd/Ctrl+K focuses search
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault(); searchInput.focus(); searchInput.select();
      }
    });

    // ---------------------- Init ----------------------
    loadCatalog();
  </script>
</body>
</html>
